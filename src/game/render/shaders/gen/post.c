// Generated by metagen.lua

void shader_post_set_draw_params(rhi_command_list_t *list, post_draw_parameters_t *params)
{
	rhi_validate_texture_srv(params->bloom0, S("post_draw_parameters_t::bloom0"), RhiValidateTextureSrv_may_be_null);
	rhi_validate_texture_srv(params->blue_noise, S("post_draw_parameters_t::blue_noise"), 0);
	rhi_validate_texture_srv(params->depth_buffer, S("post_draw_parameters_t::depth_buffer"), RhiValidateTextureSrv_is_msaa|RhiValidateTextureSrv_may_be_null);
	rhi_validate_texture_srv(params->hdr_color, S("post_draw_parameters_t::hdr_color"), RhiValidateTextureSrv_is_msaa|RhiValidateTextureSrv_may_be_null);
	rhi_validate_texture_srv(params->resolved_color, S("post_draw_parameters_t::resolved_color"), RhiValidateTextureSrv_may_be_null);
	rhi_validate_texture_srv(params->shadow_map, S("post_draw_parameters_t::shadow_map"), RhiValidateTextureSrv_may_be_null);
	rhi_set_parameters(list, 0, params, sizeof(*params));
}

#define DF_SHADER_POST_SOURCE_CODE \
	"// Generated by metagen.lua\n" \
	"\n" \
	"#include \"bindless.hlsli\"\n" \
	"\n" \
	"#include \"common.hlsli\"\n" \
	"\n" \
	"// TODO: Split resolve and post pass parameters up properly\n" \
	"\n" \
	"// 0: lerp\n" \
	"// 1: screen\n" \
	"#define BLOOM_BLEND 1\n" \
	"\n" \
	"struct post_draw_parameters_t\n" \
	"{\n" \
	"	df::Resource< Texture2D< float3 > > bloom0;\n" \
	"	float bloom_amount;\n" \
	"	int sample_count;\n" \
	"	uint pad0;\n" \
	"	df::Resource< Texture2D< float4 > > blue_noise;\n" \
	"	uint3 pad1;\n" \
	"	df::Resource< Texture2DMS< float > > depth_buffer;\n" \
	"	uint3 pad2;\n" \
	"	df::Resource< Texture2DMS< float3 > > hdr_color;\n" \
	"	uint3 pad3;\n" \
	"	df::Resource< Texture2D< float3 > > resolved_color;\n" \
	"	uint3 pad4;\n" \
	"	df::Resource< Texture2D< float > > shadow_map;\n" \
	"};\n" \
	"\n" \
	"ConstantBuffer< post_draw_parameters_t > draw : register(b0);\n" \
	"\n" \
	"\n" \
	"\n" \
	"float3 fog_blend(float3 color, float4 fog)\n" \
	"{\n" \
	"    return color*fog.a + fog.rgb;\n" \
	"}\n" \
	"\n" \
	"float henyey_greenstein(float3 v, float3 l, float k)\n" \
	"{\n" \
	"    float numerator = (1.0 - k*k);\n" \
	"    float denominator = square(1.0 - k*dot(l, v));\n" \
	"    return (1.0 / (4*PI))*(numerator / denominator);\n" \
	"}\n" \
	"\n" \
	"float4 integrate_fog(float2 uv, uint2 co, float dither, int sample_index)\n" \
	"{\n" \
	"	float3 o, d;\n" \
	"	camera_ray(uv, o, d);\n" \
	"\n" \
	"	float max_march_distance = 1024.0;\n" \
	"	int   steps              = 1;\n" \
	"\n" \
	"	float t_step = 1.0 / float(steps);\n" \
	"	float depth  = 1.0 / draw.depth_buffer.Get().Load(co, sample_index);\n" \
	"	float t      = dither*t_step;\n" \
	"\n" \
	"	float stop_distance = min(depth, max_march_distance);\n" \
	"\n" \
	"    float density    = view.fog_density;\n" \
	"    float absorption = view.fog_absorption;\n" \
	"    float scattering = view.fog_scattering;\n" \
	"    float extinction = absorption + scattering;\n" \
	"    float phase_k    = view.fog_phase_k;\n" \
	"    float sun_phase  = henyey_greenstein(d, view.sun_direction, phase_k);\n" \
	"\n" \
	"    float3 ambient = view.fog_ambient_inscattering;\n" \
	"\n" \
	"    float3 illumination = 0.0;\n" \
	"    float  transmission = 1.0;\n" \
	"    for (int i = 0; i < steps; i++)\n" \
	"    {\n" \
	"        float step_size = stop_distance*t_step;\n" \
	"\n" \
	"        float  dist = stop_distance*t;\n" \
	"        float3 p    = o + dist*d;\n" \
	"\n" \
	"        transmission *= exp(-density*extinction*step_size);\n" \
	"\n" \
	"        float3 direct_light = rcp(4.0*PI)*ambient;\n" \
	"\n" \
	"        float sun_shadow = SampleSunShadow(draw.shadow_map.Get(), p);\n" \
	"        direct_light += view.sun_color*sun_shadow*sun_phase;\n" \
	"\n" \
	"        float3 in_scattering  = direct_light;\n" \
	"        float  out_scattering = scattering*density;\n" \
	"\n" \
	"        float3 current_light = in_scattering*out_scattering;\n" \
	"\n" \
	"        illumination += transmission*current_light*step_size;    \n" \
	"        t += t_step;\n" \
	"    }\n" \
	"\n" \
	"    float remainder = depth - stop_distance;\n" \
	"    if (isinf(remainder))\n" \
	"    {\n" \
	"        transmission  = 0.0;\n" \
	"        illumination += view.sun_color*sun_phase*scattering*density*rcp(density*extinction);\n" \
	"    }\n" \
	"    else\n" \
	"    {\n" \
	"        transmission *= exp(-remainder*density*extinction);\n" \
	"        illumination += transmission*view.sun_color*sun_phase*scattering*density*remainder;\n" \
	"    }\n" \
	"    \n" \
	"    return float4(illumination, transmission);\n" \
	"}\n" \
	"\n" \
	"float3 reversible_tonemap(float3 color)\n" \
	"{\n" \
	"	return color*rcp(1 + max(color.r, max(color.g, color.b)));\n" \
	"}\n" \
	"\n" \
	"float3 reversible_tonemap_inverse(float3 color)\n" \
	"{\n" \
	"	return color*rcp(1 - max(color.r, max(color.g, color.b)));\n" \
	"}\n" \
	"\n" \
	"float4 resolve_msaa_ps(fullscreen_triangle_vs_out_t IN) : SV_Target\n" \
	"{\n" \
	"	float2 uv = IN.uv;\n" \
	"	uint2  co = uint2(IN.pos.xy);\n" \
	"\n" \
	"	Texture2DMS<float3> tex_color      = draw.hdr_color .Get();\n" \
	"	Texture2D  <float4> tex_blue_noise = draw.blue_noise.Get();\n" \
	"\n" \
	"	float4 blue_noise = tex_blue_noise.Load(uint3(co % 64, 0));\n" \
	"\n" \
	"    const float phi = 0.5*(1.0 + sqrt(5));\n" \
	"\n" \
	"	float4 sum = 0.0;\n" \
	"	for (int i = 0; i < draw.sample_count; i++)\n" \
	"	{\n" \
	"		float3 color = tex_color.Load(co, i).rgb;\n" \
	"\n" \
	"        float dither = frac(blue_noise[i % 4] + phi*float(i / 4));\n" \
	"\n" \
	"		float4 fog = integrate_fog(IN.uv, co, blue_noise.a, i);\n" \
	"		color = fog_blend(color, fog);\n" \
	"\n" \
	"		// float2 sample_position = tex_color.GetSamplePosition(i);\n" \
	"		float  weight          = 1.0;\n" \
	"\n" \
	"		// tonemap\n" \
	"		color = reversible_tonemap(color.rgb);\n" \
	"		color *= weight;\n" \
	"\n" \
	"		sum.rgb += color.rgb;\n" \
	"		sum.a   += weight;\n" \
	"	}\n" \
	"\n" \
	"	sum.rgb *= rcp(sum.a);\n" \
	"	sum.rgb  = reversible_tonemap_inverse(sum.rgb);\n" \
	"\n" \
	"	return float4(sum.rgb, 1.0);\n" \
	"}\n" \
	"\n" \
	"float4 post_ps(fullscreen_triangle_vs_out_t IN) : SV_Target\n" \
	"{\n" \
	"	float2 uv = IN.uv;\n" \
	"	uint2  co = uint2(IN.pos.xy);\n" \
	"\n" \
	"	Texture2D<float3> tex_color      = draw.resolved_color.Get();\n" \
	"	Texture2D<float4> tex_blue_noise = draw.blue_noise    .Get();\n" \
	"\n" \
	"	float3 color      = tex_color     .Load(uint3(co, 0));\n" \
	"	float4 blue_noise = tex_blue_noise.Load(uint3(co % 64, 0));\n" \
	"\n" \
	"	float3 bloom = draw.bloom0.Get().SampleLevel(df::s_linear_clamped, uv, 0);\n" \
	"\n" \
	"#if BLOOM_BLEND == 0\n" \
	"	color = lerp(color, bloom, draw.bloom_amount);\n" \
	"	color = 1.0 - exp(-color);\n" \
	"#elif BLOOM_BLEND == 1\n" \
	"	color = 1.0 - exp(-color);\n" \
	"	bloom = 1.0 - exp(-bloom);\n" \
	"	color = 1.0 - (1.0 - color)*(1.0 - draw.bloom_amount*bloom);\n" \
	"#endif\n" \
	"\n" \
	"	float3 dither = RemapTriPDF(blue_noise.rgb) / 255.0;\n" \
	"	color += dither;\n" \
	"\n" \
	"	return float4(color, 1.0);\n" \
	"}\n" \
	"\n" \
