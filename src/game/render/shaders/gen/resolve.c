// Generated by metagen.lua

void shader_set_params__resolve_draw_parameters_t(rhi_command_list_t *list, uint32_t slot, resolve_draw_parameters_t *params)
{
	rhi_validate_texture_srv(params->blue_noise, S("resolve_draw_parameters_t::blue_noise"), 0);
	rhi_validate_texture_srv(params->depth_buffer, S("resolve_draw_parameters_t::depth_buffer"), RhiValidateTextureSrv_is_msaa);
	rhi_validate_texture_srv(params->fogmap, S("resolve_draw_parameters_t::fogmap"), 0);
	rhi_validate_texture_srv(params->hdr_color, S("resolve_draw_parameters_t::hdr_color"), RhiValidateTextureSrv_is_msaa);
	rhi_validate_texture_srv(params->shadow_map, S("resolve_draw_parameters_t::shadow_map"), 0);
	rhi_set_parameters(list, slot, params, sizeof(*params));
}

#define DF_SHADER_RESOLVE_SOURCE_CODE \
	"// Generated by metagen.lua from resolve.metashader\n" \
	"\n" \
	"#include \"common.hlsli\"\n" \
	"\n" \
	"#include \"gen/resolve.hlsli\"\n" \
	"\n" \
	"ConstantBuffer< resolve_draw_parameters_t > draw : register(b0);\n" \
	"\n" \
	"float3 fog_blend(float3 color, float4 fog)\n" \
	"{\n" \
	"    return color*fog.a + fog.rgb;\n" \
	"}\n" \
	"\n" \
	"float henyey_greenstein(float3 v, float3 l, float k)\n" \
	"{\n" \
	"    float numerator = (1.0 - k*k);\n" \
	"    float denominator = square(1.0 - k*dot(l, v));\n" \
	"    return (1.0 / (4*PI))*(numerator / denominator);\n" \
	"}\n" \
	"\n" \
	"float3 sample_fog_map(float3 p)\n" \
	"{\n" \
	"	Texture3D<float4> fogmap = draw.fogmap.Get();\n" \
	"\n" \
	"    float3 sample_p = (p - view.fog_offset) / view.fog_dim + 0.5f;\n" \
	"    return fogmap.SampleLevel(df::s_linear_border, sample_p, 0).rgb;\n" \
	"}\n" \
	"\n" \
	"float4 integrate_fog(float2 uv, uint2 co, float dither, int sample_index)\n" \
	"{\n" \
	"    float density = view.fog_density;\n" \
	"\n" \
	"	if (density <= 0.0)\n" \
	"	{\n" \
	"		return float4(0, 0, 0, 1);\n" \
	"	}\n" \
	"\n" \
	"	float3 o, d;\n" \
	"	camera_ray(uv, o, d);\n" \
	"\n" \
	"	float max_march_distance = 1024.0;\n" \
	"	int   steps              = 4;\n" \
	"\n" \
	"	float t_step = 1.0 / float(steps);\n" \
	"	float depth  = 1.0 / draw.depth_buffer.Get().Load(co, sample_index);\n" \
	"	float t      = dither*t_step;\n" \
	"\n" \
	"	float stop_distance = min(depth, max_march_distance);\n" \
	"\n" \
	"    float absorption = view.fog_absorption;\n" \
	"    float scattering = view.fog_scattering;\n" \
	"    float extinction = absorption + scattering;\n" \
	"    float phase_k    = view.fog_phase_k;\n" \
	"    float sun_phase  = henyey_greenstein(d, view.sun_direction, phase_k);\n" \
	"\n" \
	"    float3 ambient = view.fog_ambient_inscattering;\n" \
	"\n" \
	"    float3 illumination = 0.0;\n" \
	"    float  transmission = 1.0;\n" \
	"    for (int i = 0; i < steps; i++)\n" \
	"    {\n" \
	"        float step_size = stop_distance*t_step;\n" \
	"\n" \
	"        float  dist = stop_distance*t;\n" \
	"        float3 p    = o + dist*d;\n" \
	"\n" \
	"        transmission *= exp(-density*extinction*step_size);\n" \
	"\n" \
	"        float3 direct_light = rcp(4.0f*PI)*(sample_fog_map(p) + ambient);\n" \
	"\n" \
	"        float sun_shadow = SampleSunShadow(draw.shadow_map.Get(), p);\n" \
	"        direct_light += view.sun_color*sun_shadow*sun_phase;\n" \
	"\n" \
	"        float3 in_scattering  = direct_light;\n" \
	"        float  out_scattering = scattering*density;\n" \
	"\n" \
	"        float3 current_light = in_scattering*out_scattering;\n" \
	"\n" \
	"        illumination += transmission*current_light*step_size;    \n" \
	"        t += t_step;\n" \
	"    }\n" \
	"\n" \
	"    float remainder = depth - stop_distance;\n" \
	"    if (isinf(remainder))\n" \
	"    {\n" \
	"        transmission  = 0.0;\n" \
	"        illumination += view.sun_color*sun_phase*scattering*density*rcp(density*extinction);\n" \
	"    }\n" \
	"    else\n" \
	"    {\n" \
	"        transmission *= exp(-remainder*density*extinction);\n" \
	"        illumination += transmission*view.sun_color*sun_phase*scattering*density*remainder;\n" \
	"    }\n" \
	"    \n" \
	"    return float4(illumination, transmission);\n" \
	"}\n" \
	"\n" \
	"float3 reversible_tonemap(float3 color)\n" \
	"{\n" \
	"	return color*rcp(1 + max(color.r, max(color.g, color.b)));\n" \
	"}\n" \
	"\n" \
	"float3 reversible_tonemap_inverse(float3 color)\n" \
	"{\n" \
	"	return color*rcp(1 - max(color.r, max(color.g, color.b)));\n" \
	"}\n" \
	"\n" \
	"float4 resolve_msaa_ps(fullscreen_triangle_vs_out_t IN) : SV_Target\n" \
	"{\n" \
	"	float2 uv = IN.uv;\n" \
	"	uint2  co = uint2(IN.pos.xy);\n" \
	"\n" \
	"	Texture2DMS<float3> tex_color      = draw.hdr_color .Get();\n" \
	"	Texture2D  <float4> tex_blue_noise = draw.blue_noise.Get();\n" \
	"\n" \
	"	float4 blue_noise = tex_blue_noise.Load(uint3(co % 64, 0));\n" \
	"\n" \
	"    const float phi = 0.5*(1.0 + sqrt(5));\n" \
	"\n" \
	"	float4 sum = 0.0;\n" \
	"	for (int i = 0; i < draw.sample_count; i++)\n" \
	"	{\n" \
	"		float3 color = tex_color.Load(co, i).rgb;\n" \
	"\n" \
	"        float dither = frac(blue_noise[i % 4] + phi*float(i / 4));\n" \
	"\n" \
	"		float4 fog = integrate_fog(IN.uv, co, blue_noise.a, i);\n" \
	"		color = fog_blend(color, fog);\n" \
	"\n" \
	"		// float2 sample_position = tex_color.GetSamplePosition(i);\n" \
	"		float  weight          = 1.0;\n" \
	"\n" \
	"		// tonemap\n" \
	"		color = reversible_tonemap(color.rgb);\n" \
	"		color *= weight;\n" \
	"\n" \
	"		sum.rgb += color.rgb;\n" \
	"		sum.a   += weight;\n" \
	"	}\n" \
	"\n" \
	"	sum.rgb *= rcp(sum.a);\n" \
	"	sum.rgb  = reversible_tonemap_inverse(sum.rgb);\n" \
	"\n" \
	"	return float4(sum.rgb, 1.0);\n" \
	"}\n" \
	"\n" \
