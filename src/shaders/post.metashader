#include "common.hlsli"

// TODO: Split resolve and post pass parameters up properly

// 0: lerp
// 1: screen
#define BLOOM_BLEND 1

@metashader
{
	name = "post",

	draw_parameters = {
		--// resolve
		hdr_color      = Texture2DMS(float3, { may_be_null = true }),
		depth_buffer   = Texture2DMS(float,  { may_be_null = true }),
		shadow_map     = Texture2D  (float,  { may_be_null = true }),
		blue_noise     = Texture2D  (float4),
		sample_count   = int,
		--// post process
		resolved_color = Texture2D(float3, { may_be_null = true }),
		bloom0         = Texture2D(float3, { may_be_null = true }),
		bloom_amount   = float,
	},

	shaders = {
		resolve_msaa_ps = { target = "ps_6_6", entry = "resolve_msaa_ps" },
		post_ps         = { target = "ps_6_6", entry = "post_ps" },
	},

	psos = {
		resolve_msaa = pso_fullscreen("resolve_msaa_ps", "r16g16b16a16_float"),
		post_process = pso_fullscreen("post_ps",         "r8g8b8a8_unorm_srgb"),
	},
}

float3 fog_blend(float3 color, float4 fog)
{
    return color*fog.a + fog.rgb;
}

float henyey_greenstein(float3 v, float3 l, float k)
{
    float numerator = (1.0 - k*k);
    float denominator = square(1.0 - k*dot(l, v));
    return (1.0 / (4*PI))*(numerator / denominator);
}

float4 integrate_fog(float2 uv, uint2 co, float dither, int sample_index)
{
	float3 o, d;
	camera_ray(uv, o, d);

	float max_march_distance = 1024.0;
	int   steps              = 1;

	float t_step = 1.0 / float(steps);
	float depth  = 1.0 / draw.depth_buffer.Get().Load(co, sample_index);
	float t      = dither*t_step;

	float stop_distance = min(depth, max_march_distance);

    float density    = view.fog_density;
    float absorption = view.fog_absorption;
    float scattering = view.fog_scattering;
    float extinction = absorption + scattering;
    float phase_k    = view.fog_phase_k;
    float sun_phase  = henyey_greenstein(d, view.sun_direction, phase_k);

    float3 ambient = view.fog_ambient_inscattering;

    float3 illumination = 0.0;
    float  transmission = 1.0;
    for (int i = 0; i < steps; i++)
    {
        float step_size = stop_distance*t_step;

        float  dist = stop_distance*t;
        float3 p    = o + dist*d;

        transmission *= exp(-density*extinction*step_size);

        float3 direct_light = rcp(4.0*PI)*ambient;

        float sun_shadow = SampleSunShadow(draw.shadow_map.Get(), p);
        direct_light += view.sun_color*sun_shadow*sun_phase;

        float3 in_scattering  = direct_light;
        float  out_scattering = scattering*density;

        float3 current_light = in_scattering*out_scattering;

        illumination += transmission*current_light*step_size;    
        t += t_step;
    }

    float remainder = depth - stop_distance;
    if (isinf(remainder))
    {
        transmission  = 0.0;
        illumination += view.sun_color*sun_phase*scattering*density*rcp(density*extinction);
    }
    else
    {
        transmission *= exp(-remainder*density*extinction);
        illumination += transmission*view.sun_color*sun_phase*scattering*density*remainder;
    }
    
    return float4(illumination, transmission);
}

float3 reversible_tonemap(float3 color)
{
	return color*rcp(1 + max(color.r, max(color.g, color.b)));
}

float3 reversible_tonemap_inverse(float3 color)
{
	return color*rcp(1 - max(color.r, max(color.g, color.b)));
}

float4 resolve_msaa_ps(fullscreen_triangle_vs_out_t IN) : SV_Target
{
	float2 uv = IN.uv;
	uint2  co = uint2(IN.pos.xy);

	Texture2DMS<float3> tex_color      = draw.hdr_color .Get();
	Texture2D  <float4> tex_blue_noise = draw.blue_noise.Get();

	float4 blue_noise = tex_blue_noise.Load(uint3(co % 64, 0));

    const float phi = 0.5*(1.0 + sqrt(5));

	float4 sum = 0.0;
	for (int i = 0; i < draw.sample_count; i++)
	{
		float3 color = tex_color.Load(co, i).rgb;

        float dither = frac(blue_noise[i % 4] + phi*float(i / 4));

		float4 fog = integrate_fog(IN.uv, co, blue_noise.a, i);
		color = fog_blend(color, fog);

		// float2 sample_position = tex_color.GetSamplePosition(i);
		float  weight          = 1.0;

		// tonemap
		color = reversible_tonemap(color.rgb);
		color *= weight;

		sum.rgb += color.rgb;
		sum.a   += weight;
	}

	sum.rgb *= rcp(sum.a);
	sum.rgb  = reversible_tonemap_inverse(sum.rgb);

	return float4(sum.rgb, 1.0);
}

float4 post_ps(fullscreen_triangle_vs_out_t IN) : SV_Target
{
	float2 uv = IN.uv;
	uint2  co = uint2(IN.pos.xy);

	Texture2D<float3> tex_color      = draw.resolved_color.Get();
	Texture2D<float4> tex_blue_noise = draw.blue_noise    .Get();

	float3 color      = tex_color     .Load(uint3(co, 0));
	float4 blue_noise = tex_blue_noise.Load(uint3(co % 64, 0));

	float3 bloom = draw.bloom0.Get().SampleLevel(df::s_linear_clamped, uv, 0);

#if BLOOM_BLEND == 0
	color = lerp(color, bloom, draw.bloom_amount);
	color = 1.0 - exp(-color);
#elif BLOOM_BLEND == 1
	color = 1.0 - exp(-color);
	bloom = 1.0 - exp(-bloom);
	color = 1.0 - (1.0 - color)*(1.0 - draw.bloom_amount*bloom);
#endif

	float3 dither = RemapTriPDF(blue_noise.rgb) / 255.0;
	color += dither;

	return float4(color, 1.0);
}
