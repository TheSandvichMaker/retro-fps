#include "common.hlsli"

@metashader
{
	exports = {
		brush_pass_parameters_t = cbuffer {
			positions     = StructuredBuffer(float3),
			uvs           = StructuredBuffer(float2),
			lm_uvs        = StructuredBuffer(float2),
			sun_shadowmap = Texture2D(float),
		},

		brush_draw_parameters_t = cbuffer {
			albedo       = Texture2D(float3),
			albedo_dim   = float2,
			lightmap     = Texture2D(float3),
			lightmap_dim = float2,
			normal       = float3,
		},
	},

	pass_parameters = brush_pass_parameters_t,
	draw_parameters = brush_draw_parameters_t,

	shaders = {
		brush_vs = { target = "vs_6_6" },
		brush_ps = { target = "ps_6_6" },
	},

	psos = {
		brush = {
			vs = "brush_vs",
			ps = "brush_ps",

			multisample = true,

			cull_mode = "back",
			depth_test  = true,
			depth_write = true,
			depth_func  = "greater",
			dsv_format  = "d24_unorm_s8_uint",

			render_targets = {
				{ pf = "r16g16b16a16_float" },
			},
		},
	},
}

struct VS_OUT
{
	float4 position           : SV_Position;
	float4 shadowmap_position : SHADOWMAP_POSITION;
	float2 uv                 : TEXCOORD;
	float2 lightmap_uv        : LIGHTMAP_TEXCOORD;
};

VS_OUT brush_vs(uint vertex_index : SV_VertexID)
{
	float3 position    = pass.positions.Get().Load(vertex_index);
	float2 uv          = pass.uvs      .Get().Load(vertex_index);
	float2 lightmap_uv = pass.lm_uvs   .Get().Load(vertex_index);

	VS_OUT OUT;
	OUT.position           = mul(view.world_to_clip, float4(position, 1));
	OUT.shadowmap_position = mul(view.sun_matrix,    float4(position, 1));
	OUT.uv                 = uv;
	OUT.lightmap_uv        = lightmap_uv;
	return OUT;
}

float4 brush_ps(VS_OUT IN) : SV_Target
{
	Texture2D<float3> tex_albedo   = draw.albedo  .Get();
	Texture2D<float3> tex_lightmap = draw.lightmap.Get();
	float2            albedo_dim   = draw.albedo_dim;
	float2            lightmap_dim = draw.lightmap_dim;

	float3 albedo = tex_albedo  .Sample(df::s_aniso_wrap, FatPixel(albedo_dim, IN.uv)).rgb;
	float3 light  = tex_lightmap.Sample(df::s_aniso_clamped, IN.lightmap_uv/*FatPixel(lightmap_dim, IN.lightmap_uv)*/).rgb;

	const float3 shadow_test_pos   = IN.shadowmap_position.xyz / IN.shadowmap_position.w;
	const float2 shadow_test_uv    = 0.5 + float2(0.5, -0.5)*shadow_test_pos.xy;
	const float  shadow_test_depth = shadow_test_pos.z;

	const float bias = max(0.025*(1.0 - max(0, dot(draw.normal, view.sun_direction))), 0.010);
	const float biased_depth = shadow_test_depth + bias;

	float2 shadowmap_dim;
	pass.sun_shadowmap.Get().GetDimensions(shadowmap_dim.x, shadowmap_dim.y);

	float shadow_factor = SampleShadowPCF3x3(pass.sun_shadowmap.Get(), shadowmap_dim, shadow_test_uv, biased_depth);

	float n_dot_l = dot(draw.normal, view.sun_direction);
	light += shadow_factor*(view.sun_color*max(0.0f, n_dot_l));

	float3 result = albedo*light;

	return float4(result, 1);
}
