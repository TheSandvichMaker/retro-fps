// Generated by metagen.lua

#include "bindless.hlsli"


	#include "common.hlsli"

	#define R_UI_RECT_BLEND_TEXT     (1 << 0)
	#define R_UI_RECT_HUE_PICKER     (1 << 1)
	#define R_UI_RECT_SAT_VAL_PICKER (1 << 2)

	struct Rect2
	{
		float2 min;
		float2 max;
	};

	bool PointInRect(Rect2 rect, float2 p)
	{
		return all(p >= rect.min) && all(p <= rect.max);
	}

	struct Rect2Fixed
	{
		uint data0;
		uint data1;
	};

	Rect2 Decode(Rect2Fixed fixed)
	{
		Rect2 result;
		result.min.x = float((fixed.data0 >>  0) & 0xFFFF);// / 4.0;
		result.min.y = float((fixed.data0 >> 16) & 0xFFFF);// / 4.0;
		result.max.x = float((fixed.data1 >>  0) & 0xFFFF);// / 4.0;
		result.max.y = float((fixed.data1 >> 16) & 0xFFFF);// / 4.0;
		return result;
	}

	struct UIRect
	{
		float2                    p_min;
		float2                    p_max;
		float2                    uv_min;
		float2                    uv_max;
		float4                    roundedness;
		ColorRGBA8                colors[4];
		float                     shadow_radius;
		float                     shadow_amount;
		float                     inner_radius;
		uint                      flags;
		Rect2Fixed                clip_rect;
		df::Resource< Texture2D > texture;
	};

	struct ui_heatmap_draw_parameters_t
{
	df::Resource< StructuredBuffer< UIRect > > rects;
};

ConstantBuffer< ui_heatmap_draw_parameters_t > draw : register(b0);


	struct VSOut
	{
		float4 pos   : SV_Position;
		uint   id    : INSTANCE_ID;
		float4 color : COLOR;
		float2 uv    : UV;
	};

	float4 MainPS(VSOut IN) : SV_Target
	{
		UIRect rect = draw.rects.Get()[IN.id];

		Rect2 clip_rect = Decode(rect.clip_rect);

		float2 pos = IN.pos.xy;
		pos.y = view.view_size.y - pos.y - 1;

		if (!PointInRect(clip_rect, pos))
		{
			discard;
		}

		return float4(1.0 / 255.0f, 0.0f, 0.0f, 1.0f);
	}

	