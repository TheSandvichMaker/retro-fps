#include "build.h"

#include <stdio.h>

static bool should_ignore_file(build_job_t *job, fs_entry_t *entry)
{
    bool ignore = false;

    for (string_node_t *node = job->ignored_directories.first; node; node = node->next)
    {
        ignore |= string_find_first(entry->path, node->string) != STRING_NPOS;
    }

    for (string_node_t *node = job->ignored_files.first; node; node = node->next)
    {
        ignore |= string_match(string_strip_extension(entry->name), node->string);
    }

    return ignore;
}

static void gather_all_includes(arena_t *arena, string_t path, string_list_t *list)
{
    (void)arena;
    (void)list;

    int exit_code;
    string_t out, err;
    // TODO: Add additional includes from job
    if (os_execute_capture(string_format(temp, "cl /showIncludes %.*s", strexpand(path)), &exit_code, temp, &out, &err))
    {
        printf("lol\n%.*s", strexpand(out));
    }
}

void gather_source_files(arena_t *arena, string_t directory, build_job_t *job, source_files_t *source)
{
    for (fs_entry_t *entry = fs_scan_directory(arena, directory, FS_SCAN_RECURSIVE);
         entry;
         entry = fs_entry_next(entry))
    {
        if (string_match(strlit(".c"),   string_extension(entry->name)) ||
            string_match(strlit(".cpp"), string_extension(entry->name)) ||
            string_match(strlit(".cxx"), string_extension(entry->name)))
        {
            if (!should_ignore_file(job, entry))
            {
                source_file_t *file = m_alloc_struct(arena, source_file_t);

                file->name = entry->name;
                file->path = entry->path;
                file->last_write_time = entry->last_write_time;

                dll_push_back(source->first, source->last, file);
            }
        }
    }
}

// I reckon it would be useful to keep track of all the generated files, maybe it's not, but here you go
source_file_t *generate_file(build_context_t *context, string_t path, string_t contents)
{
    source_file_t *result = NULL;

    push_working_directory(context->build_dir)
    {
        fs_create_directory(strlit("generated"));

        push_working_directory(strlit("generated"))
        {
            result = m_alloc_struct(context->arena, source_file_t);

            result->path = string_format(context->arena, "%.*s/generated/%.*s", strexpand(context->build_dir), strexpand(path));
            result->name = string_path_leaf(result->path);

            result->flags |= SOURCE_FILE_GENERATED;
            // dll_push_back(context->first_generated_file, context->last_generated_file, result);

            fs_write_entire_file(path, contents);
        }
    }

    return result;
}

static void transform_into_stub(build_context_t *context, source_files_t *files)
{
    string_list_t stub = { 0 };

    slist_appendf(&stub, temp, "// this file was auto-generated by build.exe\n");
    slist_appendf(&stub, temp, "#define SINGLE_TRANSLATION_UNIT_BUILD\n");
    for (source_file_t *file = files->first; file; file = file->next)
    {
        slist_appendf(&stub, temp, "#include \"%.*s\"\n", strexpand(file->path));
    }

    string_t stub_string = slist_flatten(&stub, temp);
    source_file_t *file = generate_file(context, strlit("stub.c"), stub_string);
    files->first = files->last = file;
}

build_result_t build_directory(string_t directory, build_job_t *job)
{
    source_files_t source = { 0 };
    gather_source_files(temp, directory, job, &source);

    return build_files(source, job);
}

build_result_t build_files(source_files_t source, build_job_t *job)
{
    arena_marker_t temp_marker = m_get_marker(temp);

    build_context_t *context = m_alloc_struct(temp, build_context_t);
    context->arena = temp;
    context->job   = job;

    context->build_dir = string_format(context->arena, "build/%.*s", strexpand(job->configuration));
    fs_create_directory(context->build_dir);

    if (job->single_translation_unit)
    {
        transform_into_stub(context, &source);
    }

    if (job->no_std_lib)
    {
        slist_appends(&job->defines, context->arena, strlit("NO_STD_LIB"));
    }

    backend_i *backend = NULL;
    switch (job->backend)
    {
        case BACKEND_MSVC:  backend = &backend_msvc;  break;
        case BACKEND_CLANG: backend = &backend_clang; break;
    }

    if (!backend)
    {
        fprintf(stderr, "Unimplemented or invalid backend selected!\n");
        return BUILD_OTHER_FAILURE;
    }

    build_result_t result = backend->build(context, &source, job);
    m_reset_to_marker(temp, temp_marker);

    return result;
}
