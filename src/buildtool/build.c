#include "build.h"

#include <stdio.h>

static bool should_ignore_file(const compile_params_t *compile, fs_entry_t *entry)
{
    bool ignore = false;

    for (string_node_t *node = compile->ignored_directories.first; node; node = node->next)
    {
        ignore |= string_find_first(entry->path, node->string) != STRING_NPOS;
    }

    for (string_node_t *node = compile->ignored_files.first; node; node = node->next)
    {
        ignore |= string_match(string_strip_extension(entry->name), node->string);
    }

    return ignore;
}

static void gather_all_includes(arena_t *arena, string_t path, string_list_t *list)
{
    (void)arena;
    (void)list;

    int exit_code;
    string_t out, err;
    // TODO: Add additional includes from build
    if (os_execute_capture(Sf("cl /showIncludes %.*s", Sx(path)), &exit_code, temp, &out, &err))
    {
        printf("lol\n%.*s", Sx(out));
    }
}

void gather_source_files(arena_t *arena, string_t directory, const compile_params_t *compile, source_files_t *source)
{
    for (fs_entry_t *entry = fs_scan_directory(arena, directory, FS_SCAN_RECURSIVE);
         entry;
         entry = fs_entry_next(entry))
    {
        if (string_match(S(".c"),   string_extension(entry->name)) ||
            string_match(S(".cpp"), string_extension(entry->name)) ||
            string_match(S(".cxx"), string_extension(entry->name)))
        {
            if (!should_ignore_file(compile, entry))
            {
                source_file_t *file = m_alloc_struct(arena, source_file_t);

                file->name = entry->name;
                file->path = entry->path;
                file->last_write_time = entry->last_write_time;

                dll_push_back(source->first, source->last, file);
            }
        }
    }
}

// I reckon it would be useful to keep track of all the generated files, maybe it's not, but here you go
source_file_t *generate_file(build_context_t *context, string_t path, string_t contents)
{
    source_file_t *result = NULL;

    push_working_directory(context->build_dir)
    {
        fs_create_directory(S("generated"));

        push_working_directory(S("generated"))
        {
            result = m_alloc_struct(context->arena, source_file_t);

            result->path = string_format(context->arena, "%.*s/generated/%.*s", Sx(context->build_dir), Sx(path));
            result->name = string_path_leaf(result->path);

            result->flags |= SOURCE_FILE_GENERATED;

            fs_write_entire_file(path, contents);
        }
    }

    return result;
}

void transform_into_stub(build_context_t *context, source_files_t *files, string_t stub_name)
{
    string_list_t stub = { 0 };

	if (string_empty(stub_name)) stub_name = S("stub.c");

    slist_appendf(&stub, temp, "// this file was auto-generated by build.exe\n");
    slist_appendf(&stub, temp, "#define SINGLE_TRANSLATION_UNIT_BUILD\n");
    for (source_file_t *file = files->first; file; file = file->next)
    {
        slist_appendf(&stub, temp, "#include \"%.*s\"\n", Sx(file->path));
    }

    string_t stub_string = slist_flatten(&stub, temp);
    source_file_t *file = generate_file(context, Sf("%.*s.c", Sx(stub_name)), stub_string);
    files->first = files->last = file;
}

compile_error_t compile_directory(build_context_t *context, string_t directory, const build_params_t *build, const compile_params_t *compile, object_collection_t *objects)
{
    source_files_t source = { 0 };
    gather_source_files(temp, directory, compile, &source);

	return compile_files(context, source, build, compile, objects);
}

compile_error_t compile_files(build_context_t *context, source_files_t files, const build_params_t *build, const compile_params_t *compile_, object_collection_t *objects)
{
	compile_error_t result = COMPILE_ERROR_NONE;

	compile_params_t *compile = m_copy_struct(temp, compile_);

	if (compile->single_translation_unit)
	{
		transform_into_stub(context, &files, compile->stub_name);
	}

	if (build->no_std_lib)
	{
		slist_appends(&compile->defines, context->arena, S("NO_STD_LIB"));
	}

	backend_i *backend = NULL;
	switch (build->backend)
	{
		case BACKEND_MSVC:  backend = &backend_msvc;  break;
		case BACKEND_CLANG: backend = &backend_clang; break;
	}

	result = backend->compile(context, compile, &files, objects);

	return result;
}

link_error_t link_executable(build_context_t *context, const object_collection_t *objects, const build_params_t *build, const link_params_t *link)
{
	link_error_t result = LINK_ERROR_NONE;

	backend_i *backend = NULL;
	switch (build->backend)
	{
		case BACKEND_MSVC:  backend = &backend_msvc;  break;
		case BACKEND_CLANG: backend = &backend_clang; break;
	}

	result = backend->link(context, link, objects);

	if (result == BUILD_ERROR_NONE && link->copy_executables_to_run)
	{
		fs_create_directory(link->run_dir);
		fs_copy(Sf("%.*s/%.*s.exe", Sx(context->build_dir), Sx(link->output_exe)),
				Sf("%.*s/%.*s_%.*s.exe", Sx(link->run_dir), Sx(link->output_exe), Sx(build->configuration)));
		fs_copy(Sf("%.*s/%.*s.pdb", Sx(context->build_dir), Sx(link->output_exe)),
				Sf("%.*s/%.*s_%.*s.pdb", Sx(link->run_dir), Sx(link->output_exe), Sx(build->configuration)));
	}

	return result;
}

build_error_t build_directory(build_context_t *context, string_t directory, const all_params_t *params)
{
    source_files_t source = { 0 };
    gather_source_files(temp, directory, &params->compile, &source);

    return build_files(context, source, params);
}

build_error_t build_files(build_context_t *context, source_files_t source, const all_params_t *params)
{
	build_error_t result = BUILD_ERROR_NONE;

	m_scoped(temp)
	{
		object_collection_t objects = {0};
		compile_error_t compile_error = compile_files(context, source, &params->build, &params->compile, &objects);

		if (compile_error)
		{
			result = BUILD_ERROR_COMPILATION;
		}
		else
		{
			link_error_t link_error = link_executable(context, &objects, &params->build, &params->link);

			if (link_error)
			{
				result = BUILD_ERROR_LINKER;
			}
		}
	}

    return result;
}
